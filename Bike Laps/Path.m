//
//  Path.m
//  Laps
//
//  Created by finucane on 3/6/12.
//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.
//

#import "Path.h"
#import "Location.h"
#import "Logger.h"
#import "insist.h"

@implementation Path

@dynamic timestamp;
@dynamic locations;

/*this should have been dynamically generated by core data*/
- (void)insertObject:(Location *)value inLocationsAtIndex:(NSUInteger)idx
{
  NSMutableOrderedSet*set = [[NSMutableOrderedSet alloc] initWithOrderedSet:self.locations];
  [set insertObject:value atIndex:idx];
  self.locations = set;
}

- (void)removeObjectFromLocationsAtIndex:(NSUInteger)idx
{
  NSMutableOrderedSet*set = [[NSMutableOrderedSet alloc] initWithOrderedSet:self.locations];
  [set removeObjectAtIndex:idx];
  self.locations = set;
}

/*
  we are an empty path if we have no locations yet.
  it might make sense to say that less than some small number,
  like 3 locations, constitutes an empty, or an invalid
  path.
 
*/

- (BOOL)empty
{
  return [self.locations count] == 0;
}

/*
  this is just a simple way to get a region, it won't really work in general if we are crossing
  the equator or whatever the vertical version of that thing is called.
*/

- (void)boundingBoxMinLat:(double*)minLat maxLat:(double*)maxLat minLon:(double*)minLon maxLon:(double*)maxLon
{
  insist (minLat && maxLat && minLon && maxLon);
  insist (![self empty]);
  
  /*get some nice out of bound values*/
  *minLat = *minLon = -181.0;
  *maxLat = *maxLon = +181.0;
  
  for (Location*location in self.locations)
  {
    double lat = [location.latitude doubleValue];
    double lon = [location.longitude doubleValue];
    
    if (*minLat < lat)
      *minLat = lat;
    if (*maxLat > lat)
      *maxLat = lat;
    
    if (*minLon < lon)
      *minLon = lon;
    if (*maxLon > lon)
      *maxLon = lon;
  }
}

/*return the length of the path in meters*/
- (double)length
{
  double meters = 0;
  for (int i = 0; i < [self.locations count] - 1; i++)
  {
    Location*location = [self.locations objectAtIndex:i];
    Location*next = [self.locations objectAtIndex:i+1];
    meters += [next distance:location];
  }
  return meters;
}

/*
  return the time between the last location and the first in a path. this should
  always be non negative.
*/
- (NSTimeInterval)time
{
  if ([self.locations count] == 0)
    return 0;
  
  Location*last = [self.locations lastObject];
  Location*first = [self.locations firstObject];
  return [last.timestamp timeIntervalSinceDate:first.timestamp];
}

/*
 return the index in the locations array of the location closest to "location", starting
 with startIndex. if we are working around a path matching locations once we
 run out of path, then startIndex will be the last element in the path and
 this method will return startIndex as its return value.
 
 to encourage progress if the nearest match is startIndex, so no progress, 
 and some index down the line is not more than slopMeters further away from
 location than startIndex is, then the first such index is picked.
 
 on the flipside, to discourage skipping ahead on the track on figure 8 shapes, when we do make
 progress, make sure there's not an earlier unseen point that's not within slopMeters as close,
 if there is, pick that one instead.
 
 this means we can be doing 3 linear searches, but it's likely to be just a few hundred points.
 
 slopMeters should be something around 10m, whatever the GPS accuracy is. This is all for the start/finish
 being all in the same mass of points problem.
 */
- (int)nearestIndexFor:(Location*)location startIndex:(int)startIndex slopMeters:(double)slopMeters
{
  insist (startIndex >= 0 && startIndex < [self.locations count]);
  
  /*all the distance math is done in meters*/
  double smallestDistance = 1000 * 1000;
  int smallestIndex = -1;
  
  /*find the closest match in locations to "location"*/
  for (int i = startIndex; i < [self.locations count]; i++)
  {
    Location*next = [self.locations objectAtIndex:i];
    insist (next);
    double d = [next distance:location];
    insist (d >= 0);
    if (d < smallestDistance)
    {
      smallestDistance = d;
      smallestIndex = i;
    }
  }
  insist (smallestIndex >= startIndex);
  
  /*find the first match before this match that would have been acceptable*/
 
  for (int i = startIndex; i < smallestIndex; i++)
  {
    Location*sooner = [self.locations objectAtIndex:i];
    insist(sooner);
    double d = [sooner distance:location];
    insist (d >= 0);
    if (d < smallestDistance + slopMeters)
    {
      log (@"soonerIndex %d than %d", i, smallestIndex);
      smallestIndex = i;
      smallestDistance = d;
      break;
    }
  }
  
  /*there was progress so don't try and find a better match further on*/
  if (smallestIndex != startIndex)
    return smallestIndex;
  
  for (int i = smallestIndex + 1; i < [self.locations count]; i++)
  {
    Location*next = [self.locations objectAtIndex:i];
    insist(next);
    double d = [next distance:location];
    insist (d >= 0);
    if (d < smallestDistance + slopMeters)
      return i;
  }
  return smallestIndex;
}
@end
