//
//  Workout.m
//  Laps
//
//  Created by finucane on 3/6/12.
//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.
//

#import "Workout.h"
#import "Course.h"
#import "Lap.h"
#import "Location.h"
#import "insist.h"

@implementation Workout

@dynamic course;
@dynamic laps;


/*this should have been generated by core data*/
- (void)insertObject:(Lap*)value inLapsAtIndex:(NSUInteger)idx
{
  NSMutableOrderedSet*set = [[NSMutableOrderedSet alloc] initWithOrderedSet:self.laps];
  [set insertObject:value atIndex:idx];
  self.laps = set;
}

/*
  return the split for a lap. this is just the difference between the
  next lap timestamp and this one, except in the case of a last lap
  in the workout, which then is the elapsed time within that lap
  as best as we can do. in practice that last location timestamp is added
  extra to make this sort of accurate. all this discontinuity...
 
  in fact we can compute this value 2 ways. it happens to be that
  a lap split is also pretty much the difference between the last location's
  timestamp and the first. either way works.
*/

-(NSTimeInterval)splitForLap:(int)lapIndex
{
  insist (lapIndex >= 0 && lapIndex < [self.laps count]);

  NSDate*later;
  if (lapIndex < [self.laps count] - 1)
  {
    Lap*lap = [self.laps objectAtIndex:lapIndex + 1];
    later = lap.timestamp;
  }
  else
  {
    Lap*lap = [self.laps objectAtIndex:lapIndex];
    insist ([lap.locations count]);
    Location*location = [lap.locations lastObject];
    later = location.timestamp;
  }
  
  /*if a lap has just one point, its split is going to be nice and zero here*/
  Lap*lap = [self.laps objectAtIndex:lapIndex];
  return [later timeIntervalSinceDate:lap.timestamp];
}

@end
